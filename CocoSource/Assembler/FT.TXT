*ASSEM
*IO FUNCTIONS & STACK ORDER:
*
*WRITE TO STDOUT
*THIS IS EXACTLY THE SAME AS
*"WRITE BYTES" EXCEPT IT WILL
*GO TO STDOUT.
*THIS IS WHERE THE LISTING GOES.
* A = STDIN PATH
* Y = PLACE TO GET DATA FROM
* X = LENGTH
*
*READLN FROM STDIN
*THIS IS EXACTLY THE SAME AS
*"READ 1 LINE" EXCEPT IT WILL
*COME FROM STDIN.
*THE ONLY USE FOR THIS IS
*THE ASK COMMAND.
* A=STDOUT PATH
* Y=PLACE TO PUT THE DATA
* X=MAX LANGTH
*
*WRITE BYTES (TO BINARY FILE)
* A = BINARY PATH
* Y = PLACE TO GET IT FROM
* X = LENGTH
*
*READ BYTES
* A = PATH
* Y = PLACE TO PUT IT
* X = LENGTH
*
*READ 1 LINE
* A = PATH
* Y = PLACE TO PUT IT
* X = MAX LENGTH
*
*CLOSE INPUT FILE
* A = PATH
*
*OPEN A BINARY FILE (FOR IN)
* X = ASCIIZ STRING
* A = PATH
*
*OPEN A TEXT FILE (FOR IN)
* X = ASCIIZ STRING
* A = PATH
*
*IN ALL OF THE ABOVE FUNCTIONS,
*THE C BIT OF THE CONDITION
*COEDES SHOULD BE CLEAR FOR A
*SUCCESSFULL OPERATION, OR SET
*FOR A FAILED OPERATION.
*IF SET, THEN B=ERROR CODE.
*IF B=0 THEN IT IS ASSUMED TO
*BE AN EOF ERROR, AND ASSEMBLY
*WILL NOT ABORT.  OTHERWISE,
*ASSEMBLY WILL BE ABORTED, AND
*B WILL BE PASSED BACK.
*
*TEXT FILE NAME (TO ASSEMBLE)
*BINARY PATH
*STDOUT PATH
*STDIN PATH
*UNUSED PATH
*BOTTOM OF MEMORY


*PASS1 & PASS2
*
*PARAMETERS ON STACK:
*(2) ^ MACRO IN USE
*(2) ^ MACRO PARAMETERS
*(1) PATH OF TEXT FILE (IN)
*(2) LOCAL LABLE (NUMLOC)
*(2) LOCAL LABLE (ATLOC)
*PRESERVED:NONE
*B = 0 FOR ASSEMBLED OK
*B = 1 FOR FATAL ERROR


*LCOPY
*
*REGISTERS:
*Y ^ LABLE ON LINE
*U ^ LABLE ON STACK
*PRESERVED:NONE
*Y ^ END OF LABLE ON LINE
*U ^ END OF LABLE ON STACK
*THIS FUNCTION COPIES AND
*MODIFIES A LABLE.
*IT STOPS COPIENG AT THE
*FIRST INVALID CHAR'S.
*ALL FUNCTIONS THAT USE LABLES
*MUST ROUGHT THROUGH LCOPY.


*LABVAL
*
*REGISTERS:
*Y ^ LABLE ON LINE
*PRESERVED:NONE
*Y ^ END OF LABLE ON LINE
*X ^ LABLE (DESCRIPTOR)
*BEQ IF LABLE FOUND


*INSLAB
*
*REGISTERS:
*Y ^ LABLE (ON STACK)
*PRESERVED:NONE
*X ^ LABLE DESCRIPTOR
*U ^ LABLE POINTER
*BEQ IF LABLE ALREADY THERE
*INSERTS A LABLE


*FNDLAB
*
*REGISTERS:
*Y ^ LABLE ON STACK
*PRESERVED:Y
*U ^ LABLE PTR
*X ^ LABLE DESCRIPTOR
*BEQ IF FOUND
*SEARCHES FOR A LABLE

*EVAL
*
*REGISTERS:
*Y ^ EXPRESSION
*PRESERVED:U
*Y ^ END OF EXPRESSION
*X = VAL (0 IF ERROR/UNDEFINED)
*B = ERROR CODE
*EVAL ERROR & LABLE DESCRIPTOR:
* 7 = 1=EXPR ERROR / MACRO
* 6 = 1=EQU/LABLE 0=SET
* 5 =
* 4 =
* 3 =
* 2 =
* 1 = 1=UNDEFINED SYMBOL
* 0 = 0=DEFINED ON PASS1 (PASS2)

*ENLABE
*
*REGISTERS:
*Y ^ LABLE (ON LINE)
*PRESERVED:NONE
*X ^ LABLE DESCRIPTOR
*BEQ IF LABLE ALREADY THERE
*ENTERS LABLE ON PASS1

*CHKLAB
*REGISTERS:
*Y ^ LABLE (ON LINE)
*PRESERVED:NONE
*CHECKS LABLE ON PASS2
